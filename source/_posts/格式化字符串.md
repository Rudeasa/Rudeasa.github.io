---
title: 格式化字符串
date: 2022-03-09 21:17:17
tags:
    --格式化字符串


---

<!--more-->

# 格式化字符串漏洞学习1

## Printf函数介绍

在进入 printf()  函数之前,将参数从右到左依次压栈。进入printf()  之后,函数首先获取第一个参数,一次读取一个字符。如果字符不是    % ,字符直接复制到输出中。

![image-20220326121445079](https://s2.loli.net/2022/03/26/fyVuj7NP92DAtTg.png)如上图一样，格式化字符串的参数与后面实际提供的是一一对应的，就不会出现什么问题，但是如果像printf（s)这种，直接打印一个字符串，那就会产生漏洞。

## 漏洞利用

### 泄露内存数据

1、%x打印内存数据

    例如： %5$x 打印偏移为5的数据

 




2、%p打印内存数据

      %p的用法和%x的用法相同，不同的是%p会在打印的数据前面添加上0x（输出16进制数据）。

 




3、%s打印内存数据

     %i&s是打印处偏移i处地址里面数据指向的内存地址的内容。 内存小端存储 ，打印的是转换为字符串之后的形式。

 




4、%n写入内存数据

     %n和%s类似，会把%号之前的字符个数，写入第i处数据指向的地址空间


#### 栈上的数据

1. 利用 % order $ p / % order x 来获取指定参数对应栈的内存值 。(常用%p)

2. 利用 % order $ s 来获取指定变量所对应地址的内容，只不过有零截断。(这个在做某些ctf题很好用，当一个程序上来读取一个flag到一个位置，然后你在栈上构造这个位置，直接%s就出来flag了。)

   ##### 任意地址内存

    当想泄露任意地址内存的时候，就需要**想办法把地址写入栈中**。
    在一般情况下，格式化字符串也是存在栈上的，当可控的时候，就可以直接把某个地址写到这个格式化字符串上，然后找下在这个printf函数中**对应的栈偏移**，然后在用你想用的格式化字符（%p/%x/%s）来操作即可。然后在这个地方，其有个难点就是**找对应的栈偏移**。在我们实际用的时候，其实就是找栈上的某个位置对应这个格式化字符串的偏移，并且也分为32位于64位，因为其传参是不一样的。

   ###### 32位

   ![img](https://gitee.com/Rudesa/image/raw/master/img/20220309201502.png)

   这是32位的栈对应情况，就是对应找对应栈上内容 ，而不指定的%x其找寻找的时候，是看下前面有个几个对应的无指定格式化字符，就想图上的情况，再给一个%x其是会找到arg4。

   ###### 64位

   ![img](https://gitee.com/Rudesa/image/raw/master/img/20220309201604.png)

   因为64位的参数存放是优先寄存器(rdi,rsi,rdx,rcx,r8,r9)，占满以后第7个参数才会存放在栈上。这就是跟32位找偏移不同地方。

## fmtarg

fmtarg+栈中地址可以快速返回这个地址相对于格式化字符串地址的第几个参数

![image-20220309153159873](https://gitee.com/Rudesa/image/raw/master/img/20220309153200.png)

```
计算偏移地址gdb使用(以16进制显示)：
p/x 0xaaaa-0xbbbb
```



## 实例

```
#include<stdio.h>
#include<unistd.h>
int main(){
	char s[100];
	read(0,s,100);
	printf("My name is %s,I'm %d years old\n","tom",20);
	printf(s);
	return 0;

}
```

通过一个简单的例子来测试printf()的偏移参数。先给printf下断点，然后输入aaaa，查看栈空间

![image-20220309202944089](https://gitee.com/Rudesa/image/raw/master/img/20220309202944.png)

可以看到aaaa的地址为0xffffcec8,然后调用fmtarg函数查看

![image-20220309203125348](https://gitee.com/Rudesa/image/raw/master/img/20220309203125.png)

可以看到我们输入的aaaaa（不管输入什么都一样）对于printf格式化字符串的偏移参数为6（但我也不知道是不是凑巧，试着做了两三个格式化字符串printf的偏移好像都为6？），所以我们知道了相对偏移，可以通过payload+“%6$p”得到aaaa的真实地址

![image-20220309204039979](https://gitee.com/Rudesa/image/raw/master/img/20220309204040.png)

**如果我们把aaaa替换成main或者system函数，那么我们也就可以得到它们的真实地址**，上面就是通过“%6$p”泄露main的got表的真实地址。

