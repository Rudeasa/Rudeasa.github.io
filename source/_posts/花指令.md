---
title: 花指令
date: 2021-01-06 23:45:55
tags:	
	- 知识点

---

<!--more-->

## 花指令

#### 	一、什么是花指令？它的原理是什么？

**什么是花指令？**

​		就是类似“乱指令”的指令。我们知道，汇编语言其实就是机器指令的符号化，从某种程度上看，它只是更容易理解一点的机器指令而已。每一条汇编语句，在汇编时，都会根据cpu特定的指令符号表将汇编指令翻译成二进制代码。而日常应用中，我们通过VC的IDE或其它如OD等反汇编、反编译软件也可以将一个二进制程序反汇编成汇编代码。机器的一般格式为：指令＋数据。而反汇编的大致过程是：首先会确定指令开始的首地址，然后根据这个指令字判断是哪个汇编语句，然后再将后面的数据反汇编出来。由此，我们可以看到，在这一步的反汇编过程中存在漏洞：如果有人故意将错误的机器指令放在了错误的位置，那反汇编时，就有可能连同后面的数据一起错误地反汇编出来，这样，我们看到的就可能是一个错误的反汇编代码。这就是“花指令”，简而言之，花指令是利用了反汇编时单纯根据机器指令字来决定反汇编结果的漏洞。

#### 二、在什么地方使用花指令？如何使用花指令？

```
先举个例子(记为A代码段)：
　　　jz    label
　　　jnz  label
　　　db thunkcode
```

label:

以上是一个相当简单的花指令块，其中thunkcode是由应用者自己随便写的机器指令字，当然，你写的这个机器指令字不能是单字节指令(比如nop, clr,等)，否则，你的花指字就相当于白加了。那么，你要如何来使用这段代码呢？

```
假设我们待加密的代码块如下(记为B代码段)：
　　　mov ax, 8
　　　xor ax, 77

　		...
```

我们假设这B代码段是我们的加密算法所在的代码段，现在我们想要对B代码段进行保护，可以直接将A花指令块加到mov指令之前，形如：

```
　　　jz  label
　　　jnz label 
　　　db thunkcode
label:
　　　mov ax, 8
　　　xor ax, 77
　　　...
```

#### 三、如何识别花指令？如何去除花指令？

其中，对于thunkcode，**在实际使用时，可以使用任何一个多字节指令的机器指令字来代替，这样就会欺骗反汇编软件将它连同后面的mov指令的前边某一部分反汇编成一个多字节指令**。这样，我们的目的也就达到了。

由上可以看到，使用了花指令的地方，一般都会出现这样的现象：**<u>一个跳转指令，跳转到了某条语句的中间位置，而不是这条语句的开始位置。每当出现这种情况时，我们就可以断定，这里出现了花指令。</u>**

显然地，破解它的办法，就是在那个跳转到的目的地址之前将**中间的代码全部nop掉**。

#### 四、一些典型的花指令实例

当然，为了加强难度，我们可以将若干个花指令结合起来使用。比如：

```
　　　jz  label
　　　jnz label
　　　db thunkcode
label:
　　　jz  label2
　　　jnz label2
　　　db thunkcode
lable2
　　　mov ax, 8
　　　xor ax, 77
　　　...
```

也当然，针对这种情况的破解只要一层层解开它即可：我们可以先破解到以label为首字节的指令出现为止，然后再根据新的结果，破解到以label2为首字节的指令出现为止，虽然这样麻烦点，但还是不难的。

但是，如果把下面的这段代码再同其它花指令结合起来使用，可能就更复杂了：
　

```
	nop
　　　db    thunkcode 
　　　jmp    label_2 
　　　db    thunkcode 
label_1:  
　　　pop    eax 
　　　jmp    label_3 
　　　db    thunkcode,thunkcode,thunkcode 
label_3:  
　　　inc    eax 
　　　jmp   label_4 
　　　db    thunkcode,thunkcode,thunkcode 
label_4:  
　　　jmp    eax 
　　　db    thunkcode 
label_2:  
　　　.... 


这里还有一段：
　　　call label_1
　　　db thunkcode,thunkcode
　　　jmp label_4
label_1: 
　　　pop eax
　　　jmp label_2
　　　db thunkcode,thunkcode
label_2: 
　　　add eax,2
　　　jmp label_3
　　　db thunkcode
label_3: 
　　　push eax
　　　ret
　　　db thunkcode
label_4: ....
```

为了加强难度，尽可能地用call和push实现间接跳转，当然，矛矛盾盾，只是时间长点而已，世上没有绝对安全的系统。