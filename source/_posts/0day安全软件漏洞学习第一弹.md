---
title: 0day安全软件漏洞学习第一弹
date: 2022-04-01 09:12:51
tags:
    - 漏洞利用
---

<!--more-->

# 引言	

​		从今天开始将学习关于王清主编的《0day安全软件漏洞分析》，感觉学了这么久的ctf pwn的知识点，总觉得很多只是适用于ctf比赛的场景下，现在大三下也快临近实习了，觉得自己也该真正系统性地学一学实战中的一些调试以及技巧，前置知识固然重要，更重要的是能把学会的前置知识赋予实践。

​		昨晚花了一个小时看了第一章，感觉受益匪浅，虽然讲的小例子很简单，而且就算是个基础萌新都能做到，但是作者通过解释漏洞利用原理使我真正地了解了该漏洞是如何产生以及利用的，我觉得以我之前对漏洞利用的看法就是，我完成了漏洞利用之后我就不管它到底是怎么形成的，以前的我只想要结果，当然也是以前的我能力不足，也没有靠自己能去解决漏洞是如何产生的本领，如今王清的这本书在第一章就给了我一种“哇，这种小细节原来是这样的，难怪以前没懂”一种收获满满的自足感，可能学到一些零散，但是我觉得对我系统性地认识漏洞利用有很大的帮助！

## PE文件与虚拟内存之间的映射 

以前的我只知道程序的物理地址=虚拟地址-偏移，仅此而已。但是作者又解释了一个我新了解的一个知识点：**节偏移**，这对于后面那个例子详解也很重要！

首先是我之前也了解过的一些知识点：

**（1）文件偏移地址（File Offset）**

数据在PE文件中的地址叫文件偏移地址，个人认为叫做文件地址更加准确。这是文件在磁盘上存放时相对于文件开头的偏移。 

**（2）装载基址（Image Base）** 

PE装入内存时的基地址。默认情况下，EXE文件在内存中的基地址是0x00400000，DLL文件是0x10000000。这些位置可以通过修改编译选项更改。 

**（3）虚拟内存地址（Virtual Address，VA）**

 PE文件中的指令被装入内存后的地址。 

**（4）相对虚拟地址（Relative Virtual Address，RVA**）

 相对虚拟地址是内存地址相对于映射基址的偏移量。 虚拟内存地址、映射基址、相对虚拟内存地址三者之间有如下关系。

> ```
> VA= Image Base+ RVA
> ```



**上面介绍的是内存地址的计算，下面是计算内存中文件地址的计算**



![image-20220401093824972](https://s2.loli.net/2022/04/01/SAg7FKtfbh4LQWw.png)

由于内存中数据节相对于装载基址的偏移量和文件中数据节的偏移量有上述差异，所以进行文件偏移到虚拟内存地址之间的换算时，还要看所转换的地址位于第几个节内。 我们把这种由存储单位差异引起的节基址差称做节偏移，在上例中： 

- [x] .text节偏移=0x1000-0x400=0xc00 
- [x] .rdata节偏移=0x7000-0x6200=0xE00 
- [x] .data节偏移=0x9000-0x7400=0x1C00 
- [x] .rsrc节偏移=0x2D000-0x7800=0x25800 

**那么文件偏移地址与虚拟内存地址之间的换算关系可以用下面的公式来计算。** 

```
文件偏移地址 = 虚拟内存地址（VA）−装载基址（Image Base）−节偏移 
= RVA -节偏移 

例如：如果在调试时遇到虚拟内存中0x00404141处的一条指令，假设程序装在地址为0x400000，那么要换算出这条指令在文件中的偏移量，则有： 
文件偏移地址=0x00404141-0x00400000- (0x1000-0x400)=0x3541 
```

## Crack小实验 

下面直接来看实际中的样例使用这个知识点

源代码

```
#include <stdio.h>
#define PASSWORD "1234567" 
int verify_password (char *password) {           
int authenticated;           
authenticated=strcmp(password,PASSWORD); 
return authenticated; 
} 
main() {           
int valid_flag=0;           
char password[1024];           
while(1)           {                
printf("please input password:       ");                scanf("%s",password);                
valid_flag = verify_password(password);                
if(valid_flag)                
{                    
	printf("incorrect password!\n\n");                
}                
else                
{                   
printf("Congratulation! You have passed the verification!\n");              break;                
} 
}
}
```

如代码所示，我们必须输入正确的密码“1234567”才能得到密码验证的确认，跳出循环。看到程序源码后不难发现，程序是提示密码错误请求再次输入，还是提示密码正确跳出循环，完全取决于main函数中的if判断。 

![image-20220401094624224](https://s2.loli.net/2022/04/01/2lv9HtueIMyRmbL.png)

如果我们能在.exe文件中找到if判断对应的二进制机器代码，将其稍作修改，那么即使输入错误的密码，也将通过验证！本节实验就带领大家来完成这样一件事情，这实际上是一种最简单的软件破解，也被称为“爆破”。 

​		做法很简单：在ida中找到那个if判断分支，然后进入od改汇编调试，最后放入16进制编译器修改程序，完成后保存破译版exe。

## 过程

第一步，打开IDA找到if跳转汇编地址

![image-20220401095045530](https://s2.loli.net/2022/04/01/GWgFX8drKQI9HnU.png)

第二步，打开OD 跳转到该地址下断点

![image-20220401095330550](https://s2.loli.net/2022/04/01/F2b5jS3sPyYpCK1.png)

运行了一遍，确定这里就是if语句的位置，第三步，修改汇编，把jz改为jnz，意为只要我们输错密码了，程序就可以走成功那条分支。

![image-20220401095731659](https://s2.loli.net/2022/04/01/nP6FwpQxgX89CGY.png)

有个细节可以看到，原本JZ对应的机器码74变为JN对应的机器码75，接下来就是我这章真正学到的知识点了。上面只是在内存中修改程序，我们还需要在二进制文件中也修改相应的字节。这就要用到。

用LordPE打开.exe文件，查看PE文件的节信息

![image-20220401095935330](https://s2.loli.net/2022/04/01/1nzN3j6ZyDVsig8.png)

我们已经知道跳转指令在内存中的地址是VA=0x0040106E， 按照VA与文件地址的换算公式： 

文件偏移地址 = 虚拟内存地址（VA）- 装载基址（Image Base）- 节偏移

 = 0x0040106E-0x00400000-(0x00001000-0x00001000) = 0x106E 

也就是说，这条指令在PE文件中位于距离文件开始处106E字节的地方。用UltraEdit（或者其他的16进制编译器）按照二进制方式打开crack_me.exe文件，如图所示。 

![image-20220401100057557](https://s2.loli.net/2022/04/01/K7MLTSVm86t1Ndr.png)

按快捷键Ctrl+G，输入0x106E直接跳到JE指令的机器代码处

![image-20220401100115998](https://s2.loli.net/2022/04/01/EZxfg4irlCFBA7Y.png)

将这一个字节的74（JE）修改成75（JNE），保存后重新运行可执行文件。原本正确的密码“1234567”现在反而提示错误了，成功破解密码验证。 

![image-20220401100204803](https://s2.loli.net/2022/04/01/KvXqNtg5VMoHr8L.png)

## 总结

这篇文章虽然就让我学到一个知识点，但是我觉得也很关键，没有补充节偏移的这个知识点的计算，我是想不到改怎么在16进制编译器准确的定位到关键的地址，感谢王清老师的指导，在这本书的引言部分就已经带动了我的热情，希望能慢慢慢慢啃透这本书！
